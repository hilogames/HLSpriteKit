//
//  HLUglyShuffler.m
//  HLSpriteKit
//
//  Created by Karl Voskuil on 5/17/17.
//  Copyright (c) 2017 Hilo Games. All rights reserved.
//

#import "HLUglyShuffler.h"

/**
 Primitive polynomials for the Galois LFSR, in the form of "feedback terms", where the bit
 is set for each corresponding term in the polynomial.  For instance, the polynomial:

    x^5 + x^3 + x^2 + x + 1

 corresponds to the feedback term 10111 (or 0x17).  In the array, the 0th entry is the
 feedback term for a 1-bit register, so a 16-bit LFSR should use terms[15].

 Polynomials (feedback terms) taken from:
   https://users.ece.cmu.edu/~koopman/lfsr/index.html

 The data there is like this:

   register bits  feedback terms (in hex)
   -------------  ----------------------------
               4  9 C
               5  12 14 17 1B 1D 1E
               6  21 2D 30 33 36 39

 I took more-or-less the middle term from each list.  (For lower-bit LFSRs, the sequences
 generated by different polynomials are strikingly similar, so I didn't bother using more
 than one polynomial.)

 I got polynomials for 2 and 3 bits from Wikipedia:
   https://en.wikipedia.org/wiki/Linear-feedback_shift_register
*/
static const NSUInteger HLUglyShufflerLfsrFeedbackTerms[16] = { 0x0, 0x3, 0x6, 0x9,
                                                                0x17, 0x2D, 0x53, 0xB1,
                                                                0x1A7, 0x37E, 0x5ED, 0xBD9,
                                                                0x17F6, 0x3006, 0x5FFA, 0xBF68 };

/**
 ## Approach 1: Single LFSR x N Seeds and Offsets

 - Choose a single good primitive poloynomial for LFSR and stick with it.  (For one thing,
   there are nowhere near N polynomials for each LFSR.  For another thing, at least at
   small bit depths, the sequences generated by different polynomials are similar.)  This
   template permutation is good.

 - Keep in mind that the output of the LFSR is 1 to LFSR_BOUND, with no 0, so we typically
   immediately normalize to 0 by subtracting 1.

 - When using a single LFSR shuffle as a template to create N different shuffles, there
   are at least three recognizable patterns to defeat:

    1) The first item returned by the shuffle is memorable, and so should be different for
       each permutation.

    2) Short subsequences of particular items should be avoided; for instance, if 4-2-1
       appears in one shuffle, then it's okay if 5-3-2 appears in another, but it's not
       really okay if even just two of them keep recurring in most shuffles, e.g. 4-2 or
       2-4.

    3) In (2) it was implied that patterns of differences between shuffled items are less
       important than patterns of items themselves, and I think that's mostly true.  But
       as a pathological counter-example: It would be bad if we're shuffling a list of
       names and the first two names from all shuffles are always adjacent (e.g. Abby then
       Andy from one shuffle, and Barbara then Bob from another shuffle).  (An example
       with a deck of cards would be even worse -- the two and three of diamonds, then the
       3 and 4 of clubs -- but of course this PRNG should not be used for shuffling
       cards.)  The goal is not to fix the adjacency, since adjacency is fine.  But the
       goal is to fix the timing, so that a certain adjacency in the template shuffle
       happens at different times (as well as for different items, as in (2)) for
       different shuffles.

 - To perturb subsequences of particular items: Add a different constant offset to the
   outputs of each shuffle (and modulo LFSR_BOUND-1).

 - To perturb timing of different shuffles: Use a different seed for each of the N desired
   shuffles.

 - To start each shuffle on a unique item: Okay, so choosing a different seed for each
   shuffle means we've already achieved this; but now the choice of (a non-zero!) offset
   must not un-achieve it.  If the seed for each shuffle is S, and the first item of each
   shuffle is the seed itself, then the first item of each shuffle will be in order from 0
   to N-1:

      0  1  2  3  4  5  6 ...

   We can subtract 2*S to get a descending series of first items:

      0 -1 -2 -3 -4 -5 -6 ...

   And then put them back into the correct range by adding LFSR_BOUND-1 + N-1 and modulo
   by LFSR_BOUND-1.

 ## Approach 2: Single LFSR x N XORs

 - Take the output from an an appropriately-sized LFSR using S.  (Remember again the
   LFSR's range is 1 less than the full range of the register it occupies.)  Same three
   problems as listed in Approach 1.

 - XORing a certain output from the LFSR with an increasing S value is a kind of whacky
   increment or decrement to the output.  For instance:

            XOR
     output 0   1   2   3   4   5   6   7   8   9  10  11
     ----------------------------------------------------
      0     1   0   3   2   5   4   7   6   9   8  11  10
      1    27  26  25  24  31  30  29  28  19  18  17  16
     ...
     21    31  30  29  28  27  26  25  24  23  22  21  20
     22    20  21  22  23  16  17  18  19  28  29  30  31

   So with just XOR S all three problematic patterns from LFSR are addressed: the first
   item varies; subsequences of particular items are twiddled; the timing of adjacencies
   varies.

 - One complication is that the LFSR doesn't output a 0.  In a given shuffle XORed with S,
   then, there won't be an S.  (Or, if we first normalize to zero by subtracting 1 from
   the LFSR output, then the XORed output will always be missing an LFSR_BOUND-1 ^ S =
   ~S.)  We intend to patch up this hole so that the shuffle outputs every item in the
   range 0 to N-1 exactly once.  We have options:

    - Subtracting S+1 (or rather, adding LFSR_BOUND and then subtracting S+1) and modulo
      LFSR_BOUND puts the hole right at LFSR_BOUND-1, which is where we want it.  The
      problem here is that we're subtracting something related to S right after XORing by
      S (which, as mentioned, can work like an increment on some items), and so on some
      items the effects cancel each other out and we re-introduce the problem where the
      starting item of each shuffle is no longer unique.

    - We could instead put the hole at LFSR_BOUND-1 by subtracting 1 from every XOR output
      that is greater than S.  This also makes it a little hard to control the starting
      item of each shuffle.

    - We could test the XOR output to see when it equals LFSR_BOUND-1, and then change it
      to S.  Or really we could cherry-pick any of the XOR outputs between N and
      LFSR_BOUND-1, inclusive, and do the same.  But this has to coordinate with our
      starting seed to truly control the starting item of each shuffle.  For instance, if
      the LFSR output for the first item is 1, and for each shuffle we XOR with a
      different S, then for S from 0 to N-2 the XOR output will be either S-1 or S+1.  The
      repeated first item, then, comes at S=N-1 producing output S+1=N (when N is odd) and
      so the XOR output we should cherrypick is when LFSR XOR S = N then set it to S
      instead.  All of which is nasty and inelegant, but works.  Other options are
      possible, but the point is, they depend on the seed.  I think.

 ## Approach 3: Binning and Skipping N Ways

 - Divide the items into same-sized bins.  Visit each bin in a random-seeming cycle; when
   visiting a bin, select a random-seeming item from the bin to be the next shuffled item.
   This strategy emphasizes an evenly-scattered distribution more than a surprising one.
   It might be good for groups of items where the Birthday Problem would be especially
   noticeable, for instance a playlist of songs from albums where it would seem strange
   for two songs from the same album to play consecutively, or for, ya know, birthdays.

 - Visiting bins, and choosing items within bins, could be done with an LFSR or even
   pre-randomized lists of numbers, but the simplification of this approach is to do it by
   skipping through the list by (relative) primes.  The assumption of the approach is that
   it's okay to walk the bins in a repeating pattern as long as the pattern isn't
   something super-simple.  Likewise, choosing items within bins can be done in a simple
   way: Even just choosing the items in sequence (within a bin) might be acceptible,
   although we can probably do better by skipping around within the bin, too.

 - So then the only challenge here is to bin and skip N ways.  Our main variables are: a
   bin-size, which divides N items into bin-count bins; a bin-skipper, prime relative to
   bin-count; an item-skipper, prime relative to bin-size; a bin-offset, which can be used
   to vary where the bin-skipper starts; an item-offset, which can be used to vary where
   the item-skipper starts (within a bin).  I didn't get very far with my experiments
   before I started focusing more on Approach 1.  But the following are my notes-so-far.

 - Having bin skippers larger than bin-count/2 is like smaller ones going backwards.  When
   bin skippers are small (close to 0) or large (close to bin-count) then the ordered
   nature of the skipping becomes too obvious (whether ascending or descending).  So bin
   skippers should be close to bin-count/2, with the second half mirroring the first half.

 - Having a few large bins is fine for distribution, but can cause lots of misses (in the
   last bin, which will be non-full depending on N).  When bin-count is 5, then for
   worst-case N we'll have slightly less than 20% misses.  Also, when bin-count is small,
   there are not very many different ways to skip through them, because we're looking for
   a relative prime bin-skipper.  On the other hand, having lots of small bins is fine for
   distribution, too, and as a bonus it leads to fewer misses, and allows more variation
   in the choice of bin-skippers.  A quick experiment:

     Bin Count  Good Bin Skippers  Notes
     ---------  -----------------  ----------------------------------------------------
             2  -                  Arguably 1 is okay, offset to "reverse".
             3  -                  1 and 2 okay when offset: 1-2-0, 2-0-1, etc.
             4  -                  1 and 3 okay when offset: 2-3-0-1, 1-0-3-2, etc.
             5  2, 3               2: 0-2-4-1-3; 3: 0-3-1-4-2; 1 and 4 are borderline.
             6  -
             7  2, 3, 4, 5         2 and 5 are borderline: 0-2-4-6-1-3-5, 0-5-3-1-6-4-2
             8  3, 5               3: 0-3-6-1-4-7-2-5, 5: 0-5-2-7-4-1-6-3
             9  4, 5               2 and 7 are borderline; 4: 0-4-8-3-7-2-6-1-5; 5: 0-5-1-6-2-7-3-8-4
             ....

 - It's good to use a non-zero bin-offset, so that (for instance) we don't always start in
   bin 0 for all shuffles.  But bin-offset can't really be used as a *dimension* of the
   problem to make a certain shuffle unique, since it only changes the timing of the bin
   visiting, and so doesn't fundamentally perturb the pattern of the shuffle.  The same
   might be true of varying the item-offset, too, but that depends on the algorithm.

 ## Approach 4: Interleaving N Ways

 - For my first experiments I just combined a bunch of random linear transformations to
   get a pleasing distribution of items.

 - An interesting dead-end: reversing digits as a way to distribute.  It didn't usually
   combine well with other techniques, perhaps because the pattern is so recursive.

 - Another interesting dead-end: XOR with S, which makes for a fun way to unorder a set of
   shuffles N ways, but ultimately has a really hard time breaking up adjacencies, which
   are the most noticeable pattern.  (For instance, you might not know whether you'll get
   the Anne item or the Mary item for a given shuffle, but in a majority of the shuffles
   one follows the other.)

 - So one random technique that worked pretty well to break up adjacencies: Interleaving N
   ways.  Basically you interleave the first half of the list with the second half of the
   list, and produce different shuffles by rotating and reversing the second half.  So for
   N=8, all eight shuffles (S from 0 to 7) have the first four items distributed the same
   way in the output:

            S
       i    0  1  2  3  4  5  6  7
      ----------------------------
       0    0  0  0  0  0  0  0  0
       1
       2    1  1  1  1  1  1  1  1
       3
       4    2  2  2  2  2  2  2  2
       5
       6    3  3  3  3  3  3  3  3
       7

   But they each have a slightly different way of distributing the second half:

            S
       i    0  1  2  3  4  5  6  7
      ----------------------------
       0
       1    4  5  6  7  7  6  5  4
       2
       3    5  6  7  4  6  5  4  7
       4
       5    6  7  4  5  5  4  7  6
       6
       7    7  4  5  6  4  7  6  5

   This way, in a given shuffle the item 0 has equal probability of ending up adjacent to
   items 4 to 7, either before or after.  Here is the code:

     if ((shuffledItem & 0x1) == 0) {
       shuffledItem = shuffledItem / 2;
     } else if (S < N / 2) {
       if (N & 0x1) {
         shuffledItem = N / 2 + (shuffledItem / 2 + S) % (N / 2) + 1;
       } else {
         shuffledItem = N / 2 + (shuffledItem / 2 + S) % (N / 2);
       }
     } else {
       shuffledItem = N - 1 - (shuffledItem / 2 + S) % (N / 2);
     }

 - To make pretty good shuffles, we interleave N ways and then skip through those shuffles
   by a handful of small primes (relative to N).  The skipping actually gets done in the
   code before the interleaving:

     shuffledItem = (i * primes[S % primeCount]) % N;

   And then after interleaving, start each shuffle on a different item by adding S:

     shuffledItem = (shuffledItem + S) % N;
*/
@implementation HLUglyShuffler
{
  NSUInteger _shuffleIdentifier;
  NSUInteger _lfsrBound;
  NSUInteger _lfsrTranslation;
  NSUInteger _lfsrFeedbackTerm;
  NSUInteger _lfsrState;
}

- (instancetype)initWithItemCount:(NSUInteger)itemCount shuffle:(NSUInteger)shuffleIdentifier
{
  self = [super init];
  if (self) {

    _itemCount = itemCount;
    _shuffleIdentifier = shuffleIdentifier;

    [self HL_initDerived];

    [self HL_lfsrSeed];
  }
  return self;
}

- (void)HL_initDerived
{
  // note: LFSR of W bits has output range of 2^W-1.  So we use enough bits to hold values
  // up to N+1 in order to give us the full range of N.
  if (_itemCount == 0) {
    return;
  }
  NSUInteger shifting = _itemCount;
  _lfsrBound = 1;
  NSUInteger lfsrWidth = 0;
  while (shifting != 0) {
    ++lfsrWidth;
    shifting = shifting >> 1;
    _lfsrBound *= 2;
  }
  _lfsrFeedbackTerm = HLUglyShufflerLfsrFeedbackTerms[lfsrWidth - 1];
  _lfsrTranslation = _lfsrBound + _itemCount - 2 * _shuffleIdentifier - 3;
}

- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
  self = [super init];
  if (self) {
    _itemCount = (NSUInteger)[aDecoder decodeIntegerForKey:@"itemCount"];
    _shuffleIdentifier = (NSUInteger)[aDecoder decodeIntegerForKey:@"shuffleIdentifier"];
    [self HL_initDerived];
    // note: Conceivably the feedback term array might have changed since encoding, so
    // we encode the original feedback term just in case.
    _lfsrFeedbackTerm = (NSUInteger)[aDecoder decodeIntegerForKey:@"lfsrFeedbackTerm"];
    _lfsrState = (NSUInteger)[aDecoder decodeIntegerForKey:@"lfsrState"];
  }
  return self;
}

- (void)encodeWithCoder:(NSCoder *)aCoder
{
  [aCoder encodeInteger:(NSInteger)_itemCount forKey:@"itemCount"];
  [aCoder encodeInteger:(NSInteger)_shuffleIdentifier forKey:@"shuffleIdentifier"];
  [aCoder encodeInteger:(NSInteger)_lfsrFeedbackTerm forKey:@"lfsrFeedbackTerm"];
  [aCoder encodeInteger:(NSInteger)_lfsrState forKey:@"lfsrState"];
}

- (NSUInteger)nextItem
{
  NSUInteger shuffledItem;

  while (true) {

    // Approach 1:
    //shuffledItem = (_lfsrState - 1 + _lfsrBound - 1 + _itemCount - 1 - 2 * _shuffleIdentifier) % (_lfsrBound - 1);
    // note: All constant offsets from the above expression are collapsed into one translation.
    shuffledItem = (_lfsrState + _lfsrTranslation) % (_lfsrBound - 1);

    // Approach 2:
    //shuffledItem = lfsr ^ _shuffleIdentifier;
    //if (shuffledItem == _itemCount) {
    //  shuffledItem = _shuffleIdentifier;
    //}

    // Galois LFSR
    if (_lfsrState & 0x1) {
      _lfsrState = (_lfsrState >> 1) ^ _lfsrFeedbackTerm;
    } else {
      _lfsrState = (_lfsrState >> 1);
    }

    if (shuffledItem < _itemCount) {
      break;
    }
  }

  return shuffledItem;
}

- (NSUInteger)peekItem
{
  NSUInteger shuffledItem;

  while (true) {

    shuffledItem = (_lfsrState + _lfsrTranslation) % (_lfsrBound - 1);

    if (shuffledItem < _itemCount) {
      break;
    }

    // note: "Peek" implies that the shuffler won't be mutated, but I see no harm in
    // advancing the private LFSR state until the next item is in range.
    if (_lfsrState & 0x1) {
      _lfsrState = (_lfsrState >> 1) ^ _lfsrFeedbackTerm;
    } else {
      _lfsrState = (_lfsrState >> 1);
    }
  }

  return shuffledItem;
}

- (void)HL_lfsrSeed
{
  // Approach 1
  _lfsrState = _shuffleIdentifier + 1;
  // Approach 2
  //_lfsrState = 1;
}

@end

void
HLUglyShufflerDumpItems(NSUInteger itemCount)
{
  NSMutableArray *shufflers = [NSMutableArray array];
  for (NSUInteger S = 0; S < itemCount; ++S) {
    [shufflers addObject:[[HLUglyShuffler alloc] initWithItemCount:itemCount shuffle:S]];
  }

  printf("\n");
  printf("Shuffled Items by S\n\n");

  printf(" i  ");
  for (NSUInteger S = 0; S < itemCount; ++S) {
    printf("%4lu", (unsigned long)S);
  }
  printf("\n");

  printf("----");
  for (NSUInteger S = 0; S < itemCount; ++S) {
    printf("----");
  }
  printf("\n");

  for (NSUInteger item = 0; item < itemCount; ++item) {
    printf("%2lu  ", (unsigned long)item);
    for (HLUglyShuffler *shuffler in shufflers) {
      NSUInteger item = [shuffler nextItem];
      printf("%4lu", (unsigned long)item);
    }
    printf("\n");
  }
}

void
HLUglyShufflerDumpDifferences(NSUInteger itemCount)
{
  NSMutableArray *shufflers = [NSMutableArray array];
  for (NSUInteger S = 0; S < itemCount; ++S) {
    [shufflers addObject:[[HLUglyShuffler alloc] initWithItemCount:itemCount shuffle:S]];
  }

  printf("\n");
  printf("Differences to Next\n\n");

  printf(" i  ");
  for (NSUInteger S = 0; S < itemCount; ++S) {
    printf("%5lu", (unsigned long)S);
  }
  printf("\n");

  printf("----");
  for (NSUInteger S = 0; S < itemCount; ++S) {
    printf("-----");
  }
  printf("\n");

  if (itemCount == 0) {
    return;
  }
  NSUInteger currentItems[itemCount];
  for (NSUInteger S = 0; S < itemCount; ++S) {
    currentItems[S] = [shufflers[S] nextItem];
  }
  for (NSUInteger i = 0; i < itemCount; ++i) {
    printf("%2lu  ", (unsigned long)i);
    for (NSUInteger S = 0; S < itemCount; ++S) {
      HLUglyShuffler *shuffler = shufflers[S];
      NSUInteger nextItem = [shuffler nextItem];
      NSInteger difference = (NSInteger)nextItem - (NSInteger)currentItems[S];
      printf("%5ld", (long)difference);
      currentItems[S] = nextItem;
    }
    printf("\n");
  }
}

void
HLUglyShufflerDumpDifferencesHistogram(NSUInteger itemCount)
{
  NSMutableArray *shufflers = [NSMutableArray array];
  for (NSUInteger S = 0; S < itemCount; ++S) {
    [shufflers addObject:[[HLUglyShuffler alloc] initWithItemCount:itemCount shuffle:S]];
  }

  printf("\n");
  printf("Differences Histogram Across Different Shuffles\n\n");

  printf(" i  ");
  for (NSInteger d = -itemCount + 1; d < (NSInteger)itemCount; ++d) {
    printf("%5ld", (unsigned long)d);
  }
  printf("\n");

  printf("----");
  for (NSInteger d = -itemCount + 1; d < (NSInteger)itemCount; ++d) {
    printf("-----");
  }
  printf("\n");

  if (itemCount == 0) {
    return;
  }
  NSUInteger currentItems[itemCount];
  for (NSUInteger S = 0; S < itemCount; ++S) {
    currentItems[S] = [shufflers[S] nextItem];
  }
  for (NSUInteger i = 0; i < itemCount; ++i) {

    NSUInteger differencesHistogram[itemCount * 2 - 1];
    for (NSInteger d = -itemCount + 1; d < (NSInteger)itemCount; ++d) {
      differencesHistogram[d + itemCount - 1] = 0;
    }

    for (NSUInteger S = 0; S < itemCount; ++S) {
      HLUglyShuffler *shuffler = shufflers[S];
      NSUInteger nextItem = [shuffler nextItem];
      NSInteger difference = (NSInteger)nextItem - (NSInteger)currentItems[S];
      ++differencesHistogram[difference + itemCount - 1];
      currentItems[S] = nextItem;
      ++S;
    }

    printf("%2lu  ", (unsigned long)i);
    for (NSInteger d = -itemCount + 1; d < (NSInteger)itemCount; ++d) {
      if (differencesHistogram[d + itemCount - 1] == 0) {
        printf("     ");
      } else {
        printf("%5ld", (long)differencesHistogram[d + itemCount - 1]);
      }
    }
    printf("\n");
  }
}
